'use strict';
const { EmbedBuilder } = require('discord.js');
const wait = require('node:timers/promises').setTimeout; //dumb thing needed for discord to work on replies
const randomInt = (min, max) =>
  Math.floor(Math.trunc(Math.random() * (max - min) + 1) + min);

//Selects a random word from an array
const randomIndex = arr => arr[Math.trunc(Math.random() * arr.length)];
//Rounds intergers
const round = myInt => Math.trunc(myInt);

//Creates an embed
const makeEmbed = (
  title,
  description,
  fields,
  url,
  image,
  mutlifield,
  footer
) => {
  const isHexColor = hex => {
    //checks if the random color is hex to prevent crashes
    return (
      typeof hex === 'string' && hex.length === 6 && !isNaN(Number('0x' + hex))
    );
  };

  let randomColor = Math.floor(Math.random() * 16777215).toString(16);

  if (!isHexColor(randomColor)) {
    //Default hex if random color is not hex color value
    randomColor = '#ff007b';
  }

  let embed = new EmbedBuilder().setTitle(title).setColor(randomColor);

  if (description !== false) {
    embed.setDescription(description);
  }

  if (fields !== undefined) {
    fields.forEach(field => {
      embed.addField(field.label, field.val);
    });
  }
  if (mutlifield !== undefined) {
    mutlifield.forEach(field => {
      embed.addFields(field);
    });
  }

  if (url !== undefined) {
    embed.setURL(url);
  }

  if (image !== undefined) {
    embed.setImage(image);
  }

  if (footer !== undefined) {
    embed.setFooter(footer);
  }
  return embed;
};

const reply = async (interaction, msg, embed = true, isEphemeral = false) => {
  if (embed) {
    interaction.reply({ embeds: [msg], ephemeral: isEphemeral });
  } else {
    interaction.reply({ content: msg, ephemeral: isEphemeral });
  }
};

const deferReply = async (interaction, msg, embed = true) => {
  if (embed) {
    interaction.deferReply({ embeds: [msg] });
  } else {
    interaction.deferReply(msg);
  }
};

const editReply = async (interaction, msg, embed = true) => {
  await wait(2000);
  if (embed) {
    interaction.editReply({ embeds: [msg] });
  } else {
    interaction.editReply(msg);
  }
};

const editEmbed = async (interaction, embed) => {
  interaction.edit({ embeds: [embed] });
};

const sendChannelMsg = (interaction, message_emebed, isEmbeded = true) => {
  if (isEmbeded) {
    interaction.channel.send({
      embeds: [message_emebed],
    });
  } else {
    interaction.channel.send(message_emebed);
  }
};

const sendChannelMsgNoInteraction = (
  channel,
  message_emebed,
  isEmbeded = true,
  isEphemeral = false
) => {
  if (isEmbeded) {
    channel.send({
      embeds: [message_emebed],
    });
  } else {
    channel.send({ content: message_emebed, ephemeral: isEphemeral });
  }
};

const sendPrivateMessage = (author, message) => {
  author.send(message);
};

const getAuthor = async (client, authorId) => {
  return client.users.fetch(authorId, false);
};
//Capitalises first letter in a string
const capFirst = str =>
  str !== undefined
    ? str[0].toUpperCase() + str.slice(1)
    : `Mom still loves you honey, even though you were born an error`;

const emotes = [
  '🐶',
  '🐺',
  '🐷',
  '🐱',
  '🦁',
  '🐯',
  '🦒',
  '🦊',
  '🦝',
  '🐮',
  '🐗',
  '🐭',
  '🐹',
  '🐰',
  '🐻',
  '🐨',
  '🐼',
  '🐸',
  '🦓',
  '🐴',
  '🦄',
  '🐔',
  '🐲',
  '🦍',
  '🐖',
  '🦨',
  '🐳',
  '🐠',
  '🐟',
];

const getEmbed = messageWEmbed => new EmbedBuilder(messageWEmbed.embeds[0]);

const getChannelCache = interaction => {
  return interaction.member.guild.channels.cache.get(interaction.channelId);
};

const getLastMsg = async channelCache => {
  const messageId = channelCache.lastMessageId;
  return await channelCache.messages.fetch(messageId);
};

const getChannelFromClient = (client, guildId, channelId) => {
  const currentGuild = client.guilds.cache.get(guildId);
  const currentChannel = currentGuild.channels.cache.get(channelId);
  return currentChannel;
};
//Object for easy dates
const dateInfo = {
  full: () => new Date(),
  year: () => new Date().getFullYear(),
  month: () => new Date().getMonth(),
  day: () => new Date().getDay(),
  hour: () => new Date().getHours(),
  minute: () => new Date().getMinutes(),
  second: () => new Date().getSeconds(),
  milsecond: () => new Date().getMilliseconds(),
  epocSecs: () => Math.floor((new Date() - setTimoutMin(360)) / 1000),
  sinceEpoc: () => Math.round(new Date() / 1000),
  epocToTime: secs => {
    let time = new Date(secs * 1000);
    return time;
  },
};

const nullToZero = number => {
  let returnVal = 0;
  if (number !== null) {
    returnVal = number;
  }
  return returnVal;
};

exports.randomInt = randomInt;
exports.randomIndex = randomIndex;
exports.makeEmbed = makeEmbed;
exports.reply = reply;
exports.round = round;
exports.capFirst = capFirst;
exports.deferReply = deferReply;
exports.editReply = editReply;
exports.editEmbed = editEmbed;
exports.sendChannelMsg = sendChannelMsg;
exports.emotes = emotes;
exports.getEmbed = getEmbed;
exports.getChannelCache = getChannelCache;
exports.getLastMsg = getLastMsg;
exports.dateInfo = dateInfo;
exports.nullToZero = nullToZero;
exports.sendChannelMsgNoInteraction = sendChannelMsgNoInteraction;
exports.sendPrivateMessage = sendPrivateMessage;
exports.getAuthor = getAuthor;
exports.getChannelFromClient = getChannelFromClient;
